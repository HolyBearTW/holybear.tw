permissions:
  contents: write
  actions: read

name: 部署 VitePress 靜態網站到 GitHub Pages

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  full-pipeline:
    runs-on: ubuntu-latest
    steps:
      - name: 遷出程式碼
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # ...（前面 git config 步驟不用動）

      - name: 清除 Vite/VitePress 快取
        run: |
          rm -rf .vitepress/.cache .vitepress/dist .vite node_modules/.vite

      - name: 建置 VitePress 網站
        run: yarn run build

      # ★ 這步驟要緊貼在 deploy action 前，且之後不要有任何 step 動 git config
      - name: 部署前還原 git 使用者設定
        run: |
          git config --global --unset user.name || true
          git config --global --unset user.email || true

      - name: 部署到 GitHub Pages
        uses: JamesIves/github-pages-deploy-action@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          branch: gh-pages
          folder: .vitepress/dist
          clean: true

      # ★★★ 下面這些 step 建議都放在 deploy action 之後，且不要動 git config
      - name: 偵測新文章
        id: detect-new-files
        run: |
          TARGET_DIR="blog/"
          CURRENT_SHA="${{ github.sha }}"

          is_null_sha() {
            [ -z "$1" ] || [[ "$1" =~ ^0{40}$ ]]
          }

          if [ -n "${{ github.event.before }}" ] && git cat-file -e "${{ github.event.before }}" 2>/dev/null; then
            LAST_COMMIT_SHA="${{ github.event.before }}"
          elif git cat-file -e "${CURRENT_SHA}~1" 2>/dev/null; then
            LAST_COMMIT_SHA="$(git rev-parse "${CURRENT_SHA}~1")"
          else
            LAST_COMMIT_SHA=""
          fi

          OUTPUT_FILE="new_post_files.txt"
          DETECTED_FILES=""

          if is_null_sha "$LAST_COMMIT_SHA"; then
            DETECTED_FILES=$(git diff --name-only --diff-filter=A "${CURRENT_SHA}" -- "$TARGET_DIR")
          else
            DETECTED_FILES=$(git diff --name-only --diff-filter=A "${LAST_COMMIT_SHA}" "${CURRENT_SHA}" -- "$TARGET_DIR")
          fi

          echo "$DETECTED_FILES" | grep . > "$OUTPUT_FILE" || true
          if [ -s "$OUTPUT_FILE" ]; then
            echo "偵測到新文章，列表已儲存至 $OUTPUT_FILE"
            echo "has_new_files=true" >> $GITHUB_ENV
          else
            echo "沒有偵測到新文章"
            echo "has_new_files=false" >> $GITHUB_ENV
          fi

      - name: 處理並發送 Telegram 通知
        if: env.has_new_files == 'true'
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
          ORIGINAL_COMMIT: ${{ github.sha }}
        run: |
            set -e
            NEW_POST_FILES=$(cat new_post_files.txt)
            if [ -z "$NEW_POST_FILES" ]; then
            echo "文章列表為空，中止執行。"
            exit 0
            fi
            BASE_URL="https://holybear.me"
            escape_markdownv2() {
            printf "%s" "$1" | sed -e 's/[\\_*\[\]()~`>#+\-=|{}.!]/\\&/g'
            }

            for file_path in $NEW_POST_FILES; do
            echo "Processing file: $file_path"
    
            file_content=$(cat "$file_path")
            TITLE=$(echo "$file_content" | awk -F': ' '/^title:/ {print $2; exit}')
            if [ -z "$TITLE" ]; then
            TITLE=$(echo "$file_content" | awk -F'# ' '/^# / {print $2; exit}')
            fi
            [ -z "$TITLE" ] && TITLE="無標題文章"
            CATEGORY=""
            CATEGORY=$(echo "$file_content" | grep -A 1 -iE '^\s*category:' | grep -E '^\s*-\s*' | head -n1 | sed -E 's/^\s*-\s*(.*)/\1/')
            [ -z "$CATEGORY" ] && CATEGORY=$(echo "$file_content" | grep -iE '^\s*category:\s*\[.*\]' | sed -E 's/.*\[\s*([^, ]*).*/\1/')
            [ -z "$CATEGORY" ] && CATEGORY=$(echo "$file_content" | grep -iE '^\s*category:\s*[^-\[]+' | head -n1 | sed -E 's/^\s*category:\s*//')
            CATEGORY=$(echo "$CATEGORY" | sed -E 's/^[[:space:]]+|[[:space:]]+$//g' | sed -E 's/[\x27"\/]//g')
            if [ -n "$CATEGORY" ]; then
            TITLE="【${CATEGORY}】${TITLE}"
            fi
            ARTICLE_SLUG=$(echo "$file_path" | sed -E 's|^blog/(.*)\.md$|\1|')
            ARTICLE_URL="${BASE_URL}/blog/${ARTICLE_SLUG}"
    
            # ✨ START: 新增的等待檢查邏輯 ✨
            echo "等待日誌網址生效：${ARTICLE_URL}"
            timeout=180 # 最長等待 180 秒 (3 分鐘)
            interval=20 # 每 20 秒檢查一次
            elapsed=0
            while [ $elapsed -lt $timeout ]; do
            # 使用 curl 檢查 HTTP 狀態碼
            response_code=$(curl -s -o /dev/null -w "%{http_code}" "${ARTICLE_URL}")
            if [ "$response_code" -eq 200 ]; then
              echo "✅ 日誌已上線！"
            break
            fi
              echo "日誌網址尚未生效 (HTTP ${response_code})，等待 ${interval} 秒…"
            sleep $interval
            elapsed=$((elapsed + interval))
            done

            # 如果超時後網址仍然無法訪問，則跳過此檔案的通知
            if [ $elapsed -ge $timeout ]; then
              echo "❌ 等待日誌網址生效已逾時，跳過以下通知：$file_path"
            continue # 繼續處理下一個檔案
            fi
            # ✨ END: 新增的等待檢查邏輯 ✨

            COMMIT_MESSAGE=$(git log -1 --pretty=%B "$ORIGINAL_COMMIT")
            AUTHOR_NAME=$(git log -1 --pretty=%an "$ORIGINAL_COMMIT")
            ESCAPED_TITLE=$(escape_markdownv2 "$TITLE")
            ESCAPED_COMMIT_MESSAGE=$(escape_markdownv2 "$COMMIT_MESSAGE")
            ESCAPED_AUTHOR_NAME=$(escape_markdownv2 "$AUTHOR_NAME")
    
            MESSAGE=$'*📢 New push to GitHub*\n'
            MESSAGE+=$'*'"${ESCAPED_TITLE}"$'*\n'
            MESSAGE+=$'```commit\n'"${ESCAPED_COMMIT_MESSAGE}"$'\n```'
            MESSAGE+=$'➡️ [點此閱讀文章]('"${ARTICLE_URL}"$')\n'
            MESSAGE+='by `'"${ESCAPED_AUTHOR_NAME}"'`'
    
            RESPONSE=$(curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
            --data-urlencode "chat_id=${TELEGRAM_CHAT_ID}" \
            --data-urlencode "text=${MESSAGE}" \
            --data-urlencode "parse_mode=MarkdownV2" \
            --data-urlencode "disable_web_page_preview=false") # 確保這裡設為 false
      
            if echo "$RESPONSE" | grep -q '"ok":true'; then
              echo "✅ Telegram 通知已成功發送：$file_path"
            else
              echo "❌ 無法發送 Telegram 通知：$file_path"
              echo "Telegram API 回應：$RESPONSE"
            fi
            done
